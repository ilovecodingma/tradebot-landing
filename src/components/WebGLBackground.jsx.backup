import { useEffect, useRef } from 'react';
import * as THREE from 'three';

const WebGLBackground = () => {
  const containerRef = useRef(null);
  const sceneRef = useRef(null);
  const rendererRef = useRef(null);
  const animationRef = useRef(null);

  useEffect(() => {
    if (!containerRef.current) return;

    // Scene setup
    const scene = new THREE.Scene();
    sceneRef.current = scene;

    // Camera setup - 더 가까이
    const camera = new THREE.PerspectiveCamera(
      50,
      window.innerWidth / window.innerHeight,
      0.1,
      1000
    );
    camera.position.set(2, 3, 18); // 지구를 약간 위에서 보는 각도

    // 카메라 애니메이션 변수
    let cameraDistance = 18;
    let cameraAngle = 0;

    // Renderer setup
    const renderer = new THREE.WebGLRenderer({
      alpha: false,
      antialias: true
    });
    renderer.setClearColor(0x000000, 1);
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
    containerRef.current.appendChild(renderer.domElement);
    rendererRef.current = renderer;

    // Stars background
    const starsGeometry = new THREE.BufferGeometry();
    const starsMaterial = new THREE.PointsMaterial({
      color: 0xffffff,
      size: 2,
      transparent: true,
      opacity: 0.8
    });

    const starsVertices = [];
    for (let i = 0; i < 25000; i++) {
      const x = (Math.random() - 0.5) * 2000;
      const y = (Math.random() - 0.5) * 2000;
      const z = (Math.random() - 0.5) * 2000;
      starsVertices.push(x, y, z);
    }

    starsGeometry.setAttribute('position', new THREE.Float32BufferAttribute(starsVertices, 3));
    const starField = new THREE.Points(starsGeometry, starsMaterial);
    scene.add(starField);

    // Earth setup
    const earthGeometry = new THREE.SphereGeometry(5, 64, 64);

    // Create earth texture using canvas (Night view)
    const canvas = document.createElement('canvas');
    canvas.width = 2048;
    canvas.height = 1024;
    const ctx = canvas.getContext('2d');

    // Draw ocean (very dark)
    const gradient = ctx.createLinearGradient(0, 0, 0, canvas.height);
    gradient.addColorStop(0, '#000005');
    gradient.addColorStop(0.5, '#00050a');
    gradient.addColorStop(1, '#000005');
    ctx.fillStyle = gradient;
    ctx.fillRect(0, 0, canvas.width, canvas.height);

    // Draw continents (very dark gray)
    ctx.fillStyle = '#0a0a08';
    // Simple continent shapes
    const continents = [
      // Africa/Europe
      { x: 1100, y: 400, width: 400, height: 500 },
      // Americas
      { x: 300, y: 300, width: 350, height: 600 },
      // Asia
      { x: 1400, y: 300, width: 500, height: 400 },
    ];

    continents.forEach(continent => {
      ctx.beginPath();
      ctx.ellipse(continent.x, continent.y, continent.width/2, continent.height/2, 0, 0, Math.PI * 2);
      ctx.fill();
    });

    // Add city lights (bright yellow/orange dots)
    for (let i = 0; i < 3000; i++) {
      // Randomly place lights mostly on continents
      const continentIndex = Math.floor(Math.random() * continents.length);
      const continent = continents[continentIndex];

      // Position lights within continent area
      const angle = Math.random() * Math.PI * 2;
      const distance = Math.random();
      const x = continent.x + Math.cos(angle) * (continent.width / 2) * distance;
      const y = continent.y + Math.sin(angle) * (continent.height / 2) * distance;

      const brightness = Math.random();
      const size = Math.random() * 2 + 0.5;

      // Varied colors for city lights
      if (brightness > 0.7) {
        ctx.fillStyle = `rgba(255, 220, 100, ${brightness})`;
      } else {
        ctx.fillStyle = `rgba(255, 180, 50, ${brightness * 0.8})`;
      }

      ctx.beginPath();
      ctx.arc(x, y, size, 0, Math.PI * 2);
      ctx.fill();

      // Add glow effect for brighter lights
      if (brightness > 0.8) {
        ctx.fillStyle = `rgba(255, 200, 80, ${brightness * 0.3})`;
        ctx.beginPath();
        ctx.arc(x, y, size * 2, 0, Math.PI * 2);
        ctx.fill();
      }
    }

    const earthTexture = new THREE.CanvasTexture(canvas);
    earthTexture.needsUpdate = true;

    const earthMaterial = new THREE.MeshPhongMaterial({
      map: earthTexture,
      emissive: 0x000000,
      emissiveIntensity: 0,
      shininess: 5
    });

    const earth = new THREE.Mesh(earthGeometry, earthMaterial);
    earth.position.set(0, 0, 0);
    scene.add(earth);

    // Atmosphere glow
    const atmosphereGeometry = new THREE.SphereGeometry(5.2, 64, 64);
    const atmosphereMaterial = new THREE.ShaderMaterial({
      vertexShader: `
        varying vec3 vNormal;
        void main() {
          vNormal = normalize(normalMatrix * normal);
          gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
        }
      `,
      fragmentShader: `
        varying vec3 vNormal;
        void main() {
          float intensity = pow(0.6 - dot(vNormal, vec3(0.0, 0.0, 1.0)), 2.0);
          gl_FragColor = vec4(0.3, 0.6, 1.0, 1.0) * intensity;
        }
      `,
      blending: THREE.AdditiveBlending,
      side: THREE.BackSide,
      transparent: true
    });
    const atmosphere = new THREE.Mesh(atmosphereGeometry, atmosphereMaterial);
    scene.add(atmosphere);

    // Lighting for earth
    const ambientLight = new THREE.AmbientLight(0xffffff, 0.4);
    scene.add(ambientLight);

    const sunLight = new THREE.DirectionalLight(0xffffff, 1.5);
    sunLight.position.set(5, 3, 5);
    scene.add(sunLight);

    // 회전하는 궤도 링
    const createOrbitRing = (radius, color, opacity) => {
      const curve = new THREE.EllipseCurve(
        0, 0,
        radius, radius,
        0, 2 * Math.PI,
        false,
        0
      );
      const points = curve.getPoints(100);
      const geometry = new THREE.BufferGeometry().setFromPoints(points);
      const material = new THREE.LineBasicMaterial({
        color: color,
        transparent: true,
        opacity: opacity
      });
      const ellipse = new THREE.Line(geometry, material);
      ellipse.rotation.x = Math.PI / 2;
      return ellipse;
    };

    const ring1 = createOrbitRing(7, 0x00ffff, 0.3);
    const ring2 = createOrbitRing(8.5, 0xff00ff, 0.2);
    const ring3 = createOrbitRing(10, 0xffff00, 0.15);
    scene.add(ring1, ring2, ring3);

    // 파티클 플로우 시스템
    const particleCount = 500;
    const particlesGeometry = new THREE.BufferGeometry();
    const particlePositions = new Float32Array(particleCount * 3);
    const particleVelocities = [];

    for (let i = 0; i < particleCount; i++) {
      const angle = Math.random() * Math.PI * 2;
      const radius = 7 + Math.random() * 5;
      const height = (Math.random() - 0.5) * 3;

      particlePositions[i * 3] = Math.cos(angle) * radius;
      particlePositions[i * 3 + 1] = height;
      particlePositions[i * 3 + 2] = Math.sin(angle) * radius;

      particleVelocities.push({
        angle: angle,
        radius: radius,
        speed: 0.01 + Math.random() * 0.02,
        verticalSpeed: (Math.random() - 0.5) * 0.01
      });
    }

    particlesGeometry.setAttribute('position', new THREE.BufferAttribute(particlePositions, 3));
    const particlesMaterial = new THREE.PointsMaterial({
      color: 0x00ffff,
      size: 0.15,
      transparent: true,
      opacity: 0.8,
      blending: THREE.AdditiveBlending
    });
    const particleSystem = new THREE.Points(particlesGeometry, particlesMaterial);
    scene.add(particleSystem);

    // 펄스 이펙트
    const pulses = [];
    const createPulse = () => {
      const pulseGeometry = new THREE.RingGeometry(5, 5.1, 32);
      const pulseMaterial = new THREE.MeshBasicMaterial({
        color: 0xffffff,
        transparent: true,
        opacity: 1,
        side: THREE.DoubleSide
      });
      const pulse = new THREE.Mesh(pulseGeometry, pulseMaterial);
      pulse.rotation.x = Math.PI / 2;
      pulse.userData = { scale: 1, opacity: 1 };
      scene.add(pulse);
      pulses.push(pulse);
    };

    // 별똥별 시스템
    const shootingStars = [];
    const createShootingStar = () => {
      const geometry = new THREE.BufferGeometry();
      const positions = new Float32Array([
        0, 0, 0,
        -2, 0, 0
      ]);
      geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
      const material = new THREE.LineBasicMaterial({
        color: 0xffffff,
        transparent: true,
        opacity: 0.8
      });
      const star = new THREE.Line(geometry, material);

      const angle = Math.random() * Math.PI * 2;
      const radius = 50 + Math.random() * 50;
      star.position.set(
        Math.cos(angle) * radius,
        Math.random() * 30 - 15,
        Math.sin(angle) * radius
      );

      star.userData = {
        velocity: new THREE.Vector3(
          (Math.random() - 0.5) * 0.5,
          -(Math.random() * 0.3 + 0.2),
          (Math.random() - 0.5) * 0.5
        ),
        life: 1
      };

      scene.add(star);
      shootingStars.push(star);
    };

    // Mouse interaction
    let mouseX = 0;
    let mouseY = 0;
    const handleMouseMove = (event) => {
      mouseX = (event.clientX / window.innerWidth) * 2 - 1;
      mouseY = -(event.clientY / window.innerHeight) * 2 + 1;
    };
    window.addEventListener('mousemove', handleMouseMove);

    // Animation
    let time = 0;
    const animate = () => {
      animationRef.current = requestAnimationFrame(animate);
      time += 0.01;

      // 카메라 부드러운 줌인/아웃 및 회전
      cameraAngle += 0.001;
      cameraDistance = 18 + Math.sin(time * 0.3) * 2;

      const targetX = mouseX * 4 + Math.cos(cameraAngle) * 2;
      const targetY = mouseY * 4 + 3 + Math.sin(time * 0.5) * 0.5;
      const targetZ = cameraDistance;

      camera.position.x += (targetX - camera.position.x) * 0.02;
      camera.position.y += (targetY - camera.position.y) * 0.02;
      camera.position.z += (targetZ - camera.position.z) * 0.02;
      camera.lookAt(0, 0, 0);

      // 지구 자전
      earth.rotation.y += 0.002;
      atmosphere.rotation.y += 0.002;

      // 궤도 링 회전 (각각 다른 속도)
      ring1.rotation.z += 0.005;
      ring2.rotation.z -= 0.003;
      ring3.rotation.z += 0.004;

      // 파티클 업데이트
      const positions = particlesGeometry.attributes.position.array;
      for (let i = 0; i < particleCount; i++) {
        const velocity = particleVelocities[i];
        velocity.angle += velocity.speed;

        positions[i * 3] = Math.cos(velocity.angle) * velocity.radius;
        positions[i * 3 + 1] += velocity.verticalSpeed;
        positions[i * 3 + 2] = Math.sin(velocity.angle) * velocity.radius;

        // 파티클이 너무 위나 아래로 가면 리셋
        if (Math.abs(positions[i * 3 + 1]) > 5) {
          positions[i * 3 + 1] = 0;
        }
      }
      particlesGeometry.attributes.position.needsUpdate = true;

      // 펄스 업데이트
      pulses.forEach((pulse, index) => {
        pulse.userData.scale += 0.02;
        pulse.userData.opacity -= 0.01;
        pulse.scale.set(pulse.userData.scale, pulse.userData.scale, 1);
        pulse.material.opacity = pulse.userData.opacity;

        if (pulse.userData.opacity <= 0) {
          scene.remove(pulse);
          pulse.geometry.dispose();
          pulse.material.dispose();
          pulses.splice(index, 1);
        }
      });

      // 주기적으로 펄스 생성
      if (Math.random() < 0.02) {
        createPulse();
      }

      // 별똥별 업데이트
      shootingStars.forEach((star, index) => {
        star.position.add(star.userData.velocity);
        star.userData.life -= 0.01;
        star.material.opacity = star.userData.life;

        if (star.userData.life <= 0) {
          scene.remove(star);
          star.geometry.dispose();
          star.material.dispose();
          shootingStars.splice(index, 1);
        }
      });

      // 주기적으로 별똥별 생성
      if (Math.random() < 0.01) {
        createShootingStar();
      }

      // 별 회전
      starField.rotation.y += 0.0001;
      starField.rotation.x = Math.sin(time * 0.1) * 0.05;

      renderer.render(scene, camera);
    };
    animate();

    // Handle window resize
    const handleResize = () => {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    };
    window.addEventListener('resize', handleResize);

    // Cleanup
    return () => {
      window.removeEventListener('resize', handleResize);
      window.removeEventListener('mousemove', handleMouseMove);
      if (animationRef.current) {
        cancelAnimationFrame(animationRef.current);
      }
      if (containerRef.current && rendererRef.current) {
        containerRef.current.removeChild(rendererRef.current.domElement);
      }
      starsGeometry.dispose();
      starsMaterial.dispose();
      earthGeometry.dispose();
      earthMaterial.dispose();
      earthTexture.dispose();
      atmosphereGeometry.dispose();
      atmosphereMaterial.dispose();
      particlesGeometry.dispose();
      particlesMaterial.dispose();

      // 펄스 정리
      pulses.forEach(pulse => {
        pulse.geometry.dispose();
        pulse.material.dispose();
        scene.remove(pulse);
      });

      // 별똥별 정리
      shootingStars.forEach(star => {
        star.geometry.dispose();
        star.material.dispose();
        scene.remove(star);
      });

      // 링 정리
      [ring1, ring2, ring3].forEach(ring => {
        ring.geometry.dispose();
        ring.material.dispose();
        scene.remove(ring);
      });

      renderer.dispose();
    };
  }, []);

  return (
    <div
      ref={containerRef}
      style={{
        position: 'fixed',
        top: 0,
        left: 0,
        width: '100%',
        height: '100%',
        zIndex: -1,
        background: '#000000',
      }}
    />
  );
};

export default WebGLBackground;
